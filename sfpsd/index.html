<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    
    
    <link type="text/css" href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <script type="text/javascript" src="jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="jquery-ui.min.js"></script>
    <script src="colorbrewer.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBhBRV_S71WiAX-_8ZYvPdH9MzO8fnb7uY"></script>
    <style type="text/css">


.node circle {
  cursor: pointer;
  fill: rgb(0,68,104);
  stroke: rgb(0,68,104);
  stroke-width: 1.5px;
}

.node text {
  cursor: pointer;
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #f4f4f4;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container-fluid">
          <!-- Brand and toggle get grouped for better mobile display -->
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <span class="navbar-text" >New York City Facilities</span>
          </div>

          <!-- Collect the nav links, forms, and other content for toggling -->
          <div class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
              <li class="navbar-text" id= "prompt">Select Boroughs to Display: </li>
              <li><a class="boro active" id="all" onclick='javascript:toggleNYC()'>All NYC</a></li>
              <li><a class="boro active" onclick='javascript:toggleMN()'>Manhattan</a></li>
              <li><a class="boro active" onclick='javascript:toggleBK()'>Brooklyn</a></li>
              <li><a class="boro active" onclick='javascript:toggleBX()'>Bronx</a></li>
              <li><a class="boro active" onclick='javascript:toggleQN()'>Queens</a></li>
              <li><a class="boro active" onclick='javascript:toggleSI()'>Staten Island</a></li>
            </ul>
            <div class="searchbar">
              <div class="ui-widget">
                <input id="tags" placeholder="Search for a Facility or Category" >
                
              </div>
            </div>
          </div>
          
        </div><!-- /.container-fluid -->
      </nav>
      <div id="facWindow">
        <div id="facName"></div>
        <div id="map"></div>
        <ul id="facAttr">
          <li></li>
          <li></li>
        </ul>
      </div>

      <div id="pieContainer">
        <div id="catName"></div>
      </div>
        
    </div>
    <script type="text/javascript">
    initMap();
    $('.boro:not(#all)').click(function() {
      $(this).toggleClass('active');
    })

  

d3.selection.prototype.moveToBack = function() { 
    return this.each(function() { 
        var firstChild = this.parentNode.firstChild; 
        if (firstChild) { 
            this.parentNode.insertBefore(this, firstChild); 
        } 
    }); 
};
//set dimensions and margins
var m = [50, 120, 20, 85],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root;

//maximum depth of the tree, used to determine if node is leaf, FUTURE:should use a function to set
var maxDepth = 4,
  maxDescend = 0,
  map,
  labelCutoff = 35,
  selectColor = "rgb(219,105,27)",
  hoverColor = "rgb(0,68,104)",
  primaryColor = "rgb(0,68,104)",
  boroughs = ['BK', 'MN', 'BX', 'QN', 'SI'];
  currBoroughs = ['BK', 'MN', 'BX', 'QN', 'SI'];

var levelWidth, inp;

function initMap() {
  console.log("initializing map");
  // Create a map object and specify the DOM element for display.
  map = new google.maps.Map(document.getElementById('map'), {
    center: {lat: -40.7127, lng: 74.0059},
    scrollwheel: true,
    zoom: 15
  });
}

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

d3.select("#body").on("click", function() { 
      //console.log("hiding map"); 
      document.getElementById('facWindow').style.visibility = "hidden";});

var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

d3.json("SFPSDparsedattr.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  
  orderChildren(root);

  root.children.forEach(toggleAll);

  maxDescend = numDescend(root);

  update(root);

$(function() {
    var availableTags = [];

    visit(root, function(d) {
        availableTags.push(d.name);

    }, function(d) {
        if (d.children && d.children.length > 0) {
          return d.children; 
        } else if (d._children && d._children.length > 0) {
          return d._children;
        }
    });
    $( "#tags" ).autocomplete({
      source: availableTags,
      appendTo: ".searchbar",
      select: function(event, input) {startSearch(input.item.value);}
    });
  });
  
});



function toggleAll(d) {
    if (d.children) {
      orderChildren(d);
      d.children.forEach(toggleAll);
      toggle(d);
    }
}

function orderChildren(d) {
    if (d.children) {
      d.children = d.children.sort(function (a, b) {
        if (numDescend(a) > numDescend(b)) {return -1;}
        if (numDescend(a) < numDescend(b)) {return 1;}
        // a must be equal to b
        return 0;
      });
    } else if (d._children) {
      d._children = d._children.sort(function (a, b) {
        if (numDescend(a) > numDescend(b)) {return -1;}
        if (numDescend(a) < numDescend(b)) {return 1;}
        // a must be equal to b
        return 0;
      });
    }
  }

function update(source) {
  resizeSvg();
  var offset = [0,0,0,0,0];
  var currMaxDepth = 0;
  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  var radiusScale = d3.scale.log()
                    .domain([1, maxDescend])
                    .range([1, 30]);

  // set node x,y postions and count descendents
  /*nodes.forEach(function(d) {
    if(d.depth > currMaxDepth) {
      currMaxDepth = d.depth;
    }
  })
  */
  nodes.forEach(function(d) {
    d.y = d.depth * (d.depth == maxDepth ? 240 : 255);
    d.descend = numDescend(d);
    var radius = d.descend > 0 ? radiusScale(d.descend) : 0;
  
    //if ((prevNode.parent == d.parent) && (prevNode.id == d.id-1)) {
    if (d3.max(levelWidth) >= 50) {
      
      if (d.depth != maxDepth) {
        
        offset[d.depth] += radius * (offset[d.depth] == 0 ? 1 : 2);
        //d.x = d.x - d.offset;
        console.log(offset[d.depth]);
        d.x = d.x - offset[d.depth];
      }
    }
    /*
    //if overlap found and name is long and is not a leaf, offset
    if (findOverlap(d) && d.name.length > 27 && d.depth != maxDepth) {
      var newDx = d.x + 15;
      /*while(findOverlap(newDx)) {
        newDx = newDx + 15;
      }
      d.x = newDx;

    }*/
    //prevNode = d;
  });
  

  

  // Update the nodesâ€¦
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) {
        if (d.children == null) {
          d3.select(this).select("text").attr("font-weight", "bold").attr("fill", selectColor);
        } else {
          d3.select(this).select("text").attr("font-weight", "normal").attr("fill", primaryColor);
        }
        //d.children || d._children ? toggle(d) : openMap(d); 
        var svgh = d3.select("svg").attr("height");
        d.children || d._children ? toggle(d) : openMap(d); 
        update(d);
        
        var newsvgh = d3.select("svg").attr("height");
        if (svgh != newsvgh) {
          var windowh = window.innerHeight
            || document.documentElement.clientHeight
            || document.body.clientHeight;
          d.children || d._children ? window.scroll(0, d.x - windowh/2) : null;
        }
      })
      .on("mouseover", function(d) { 
        //d3.select(this).select("text").attr("fill", function(d) {return d.children ?  selectColor : hoverColor;});
        d3.select(this).select("text").attr("font-weight", "bold");
        d3.select(this).select("text").text(function(d) {return d.name;});
        if (d.name.length > labelCutoff) {
          var xpadding = 4,
              ypadding = 2,
              defaultH = 12;
          var bbox = this.getBBox();
          
          var rect = d3.select(this).append("rect")
            .attr("x", bbox.x - xpadding)
            .attr("y", bbox.y + bbox.height/2 - defaultH/2 )
            .attr("width", (bbox.width - 15) + (xpadding * 2))
            .attr("height", defaultH)
            //.insertBefore()
            .style("fill", "white")
            .moveToBack();
        }  
        
        //d.depth < (maxDepth-1) && d.descend > 0 ? openPie(d) : null;
      })
      .on("mouseout", function(d) {
        d3.select("rect").remove();  
        //d3.select(this).select("text").attr("fill", function(d) {return d.children ? selectColor : primaryColor;});
        d3.select(this).select("text").attr("font-weight", function(d) {return d.children ? "bold" : "normal";});
        d3.select(this).select("text").text(function(d) 
          {return d.name.length > labelCutoff ? d.name.substr(0,labelCutoff) + "..." : d.name;})
        document.getElementById('pieContainer').style.visibility = "hidden";
        $("#pieContainer").find("svg").remove("*");
        
        
        //d.children || d._children ? null : document.getElementById('map').style.visibility = "hidden";
        
      });

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return (d._children || d.depth == maxDepth) ? primaryColor : selectColor; });

  nodeEnter.append("svg:text")
      .attr("x", function(d) {
        var offset = 7 + (d.descend > 0 ? radiusScale(d.descend) : 0);
        return offset * (d.children || d._children ? -1 : 1); })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .attr("font-weight", function(d) { return d.children ? "bold" : "normal";})
      .attr("fill", function(d) { return d.children ? selectColor : primaryColor;})
      .text(function(d) {
        return d.name.length > labelCutoff ? d.name.substr(0,labelCutoff) + "..." : d.name;})
      .style("fill-opacity", 1e-6);

  nodeEnter.append("svg:text")
      .attr("class", "desc")
      .attr("dy", function(d) {return d.depth == 0 ? "-.35em" : ".35em"})
      .attr("text-anchor", "middle")
      .attr("font-weight", "bold")
      .attr("fill", "white")
      .text(function(d) {
        var text = (d.descend >= 5 ? d.descend : null);
        //text += d.depth == 0 ? " Facilities" : null;
        return text; });
      //.style("fill-opacity", 1e-6);
  nodeEnter.append("svg:text")
      .attr("class", "fac")
      .attr("dy", ".75em")
      .attr("text-anchor", "middle")
      .attr("font-weight", "bold")
      .attr("fill", "white")
      .text(function(d) {return d.depth == 0 && d.descend > 1 ? " Facilities" : null;});

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", function(d) {return d.descend ? radiusScale(d.descend) : .1;})
      .style("fill", function(d) { return (d._children || d.depth == maxDepth) ? primaryColor : selectColor; })
      .style("stroke", "none");

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  nodeUpdate.select(".desc")
    .text(function(d) {
        var text = (d.descend >= 5 ? d.descend : null);
        return text; });

  nodeUpdate.select(".fac")
    .text(function(d) {return d.depth == 0 && d.descend > 1 ? " Facilities" : null;});

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the linksâ€¦
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });

  firstUpdate = false;
}

// Toggle children.
/*function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
}
*/
function toggle(d) {
  if (d.children) {
    d._children = d.hidden_children ? d.children.concat(d.hidden_children) : d.children;
    d.children = null;
    d.hidden_children = null;
  } else {
    d.children = [];
    for (var i = 0; i < d._children.length; i++) {
      if(d._children[i].hasOwnProperty('attr')) {
        if(currBoroughs.indexOf(d._children[i].attr.Borough) >= 0) {
          d.children.push(d._children[i]);
        } else {
          //console.log(d._children[i]);
          d.hidden_children ? d.hidden_children.push(d._children[i]) : d.hidden_children = [d._children[i]];
        }
      } else {
        //console.log("no attributes");
        d.children.push(d._children[i]);
      }
    }

    //d.children = d._children;
    d._children = null;
  }


}

//calculates level with max number of nodes open, stores currently open nodes for each level in levelWidth array
function resizeSvg() {
  levelWidth = [1];
  var childCount = function(level, n) {
    if (n.children && n.children.length > 0) {
      if (levelWidth.length <= level + 1) levelWidth.push(0);

      levelWidth[level + 1] += n.children.length;
      n.children.forEach(function(d) {
          childCount(level + 1, d);
      });
    }
  };
  childCount(0, root);
  //resizes tree based on level with most nodes open, only resizes if there is a level with greater than 50, otherwise sets to default height
  if(d3.max(levelWidth) >= 50) {
    var newHeight = d3.max(levelWidth) * 15; // 15 pixels per line  
    tree.size([newHeight, w]);
    d3.select("svg").attr("height", newHeight + m[0]);

  } else {
    tree.size([h, w]);
    d3.select("svg").attr("height", h + m[0] + m[2]);
  }


}

// A recursive helper function for performing some setup by walking through all nodes
function visit(parent, visitFn, childrenFn) {
  if (!parent) return;

  visitFn(parent);

  var children = childrenFn(parent);
  if (children) {
    var count = children.length;
    for (var i = 0; i < count; i++) {
      visit(children[i], visitFn, childrenFn);
    }
  }
}
    
function findOverlap(node) {
  if (node.hasOwnProperty('parent')) {
    if (node.parent.hasOwnProperty('parent')) {
      var parofpar = node.parent.parent;
      for (var i = 0; i < parofpar.children.length; i++) {
        if((parofpar.children[i].x >= (node.x - 15)) && (parofpar.children[i].x <= (node.x + 15))) {
          return true;
        }
      }
    }
  }
}

function numChildren(node) {
  if (node.hasOwnProperty('children')) {
    if (node.children == null) {
      return node._children.length;
    } else {
      return node.children.length;
    }
  } else {
    return 0;
  }
}

function numDescend(node) {
  /*if(node.descend) {
    return node.descend;
  }*/
  var totDescend = 0;
  visit(node, function(d) {
        //console.log(d);
        if(!(d.children || d._children)) {
          if(currBoroughs.indexOf(d.attr.Borough) >= 0) {
            totDescend++;
          }
        }
    }, function(d) {
        var ret_value = d.children && d.children.length > 0 || d._children && d._children.length > 0 ? d.children || d._children : null;
        return ret_value;
    });
  return totDescend;
}


//
//functions to execute search
//
var foundCoord = [];
var found = false;

function findFacility(facility, node) {
  if (node == null || found == true) {
    return;
  }
  if (node.hasOwnProperty("children") == false) {
    return;
  }

  var count = 0;
  var ch = [];
  if (node.children == null) {
    count = node._children.length;
    ch = node._children;
  } else {
    count = node.children.length;
    ch = node.children;
  }
    for (var i = 0; i < count; i++) {
      if (ch[i].name.toLowerCase() == facility) {
        console.log("found!");
        foundCoord.push(i);
        found = true;
        return;
      } else {
        findFacility(facility, ch[i]);
        if (found == true) {
          foundCoord.push(i);
          return;
        }
      }
    }
  
}

function openTree(foundCoord) {
  var curr = root;
  //console.log(curr);
  while (foundCoord.length > 0) {
    var index = foundCoord.pop();
    if (curr.children == null) {
      curr = curr._children[index];
    } else {
      curr = curr.children[index];
    }
    
    if (curr.children || curr._children) { 
      toggle(curr) 
    } else {
      openMap(curr);
      var windowh = window.innerHeight
            || document.documentElement.clientHeight
            || document.body.clientHeight;
      window.scroll(0, curr.x - windowh/2);
    }
  }
  update(root);
}

function startSearch(fac) {
  foundCoord = [];
  found = false;
  console.log("starting search");
  //var toFind = (document.getElementById('tags').value).toLowerCase();
  var toFind = fac.toLowerCase();
  console.log(toFind);
  findFacility(toFind, root);
  console.log("foundCoord: " + foundCoord);
  if (foundCoord.length < 1) {
    alert(toFind + " not found");
  } else {
    console.log("opening tree");
    openTree(foundCoord);
  }
}

function openPie(fac) {
  //console.log(fac);
  drawPie(fac);
  $("#catName").text(fac.name);
  document.getElementById('pieContainer').style.visibility = "visible";
  //sets pie position - if window overlaps with banner, shifts down
  document.getElementById('pieContainer').style.top = fac.x < 115 ? "45px" : (fac.x - 70) + "px";
  document.getElementById('pieContainer').style.left = (fac.y + 90) + "px";

}

function openMap(fac) {
  console.log(fac);
  //window.open("http://maps.google.com?q=" + fac.name);
  

  var address = fac.attr.FacAddress + ", New York, New York";
  console.log(address);

  var geocoder = new google.maps.Geocoder();
  if (geocoder) {
      geocoder.geocode( { 'address': address}, function(results, status) {
        if (status == google.maps.GeocoderStatus.OK) {
          if (status != google.maps.GeocoderStatus.ZERO_RESULTS) {
          map.setCenter(results[0].geometry.location);
            var infowindow = new google.maps.InfoWindow(
                { content: '<b>'+address+'</b>',
                  size: new google.maps.Size(150,50)
                });

            var marker = new google.maps.Marker({
                position: results[0].geometry.location,
                map: map, 
                title:address
            }); 
            google.maps.event.addListener(marker, 'click', function() {
                infowindow.open(map,marker);
            });

          } else {
            alert("No results found");
          }
        } else {
          alert("Geocode was not successful for the following reason: " + status);
        }
      });
    }

  map.setCenter(new google.maps.LatLng(37.4419, -122.1419));
  map.addListener('center_changed', function() {
    document.getElementById('facWindow').style.visibility = "visible";
    $("#facName").text(fac.name);

    $("#facAttr").find("li").eq(0).text("Borough: " + fac.attr.Borough);
    $("#facAttr").find("li").eq(1).text("Address: " + fac.attr.FacAddress);

    //sets facility info window position - if window overlaps with banner, shifts down
    document.getElementById('facWindow').style.top = fac.x < 115 ? "45px" : (fac.x - 70) + "px";
    document.getElementById('facWindow').style.left = (fac.y - 280) + "px";
  });
  
  
}

function arraysEqual(a, b) {
  if (a.length != b.length) {
    return false;
  }

  a.sort();
  b.sort();

  if (JSON.stringify(a) == JSON.stringify(b)) {
    return true;
  } else {
    return false;
  }
}

function toggleNYC() {
  //if all boroughs currently selected, will unselect them all
  if (arraysEqual(currBoroughs, boroughs)) {
    for (var i = 0; i < boroughs.length; i++) {
      if (currBoroughs.indexOf(boroughs[i]) >= 0) {
        toggleBorough(boroughs[i]);
      }
    }
    $(".boro").removeClass('active');
  } else {
    for (var i = 0; i < boroughs.length; i++) {
      if (currBoroughs.indexOf(boroughs[i]) < 0) {
        toggleBorough(boroughs[i]);
      }
    }
    $(".boro").addClass('active');
  }
}

function toggleBorough(b) {
  if (currBoroughs.indexOf(b) < 0) {
    currBoroughs.push(b);
  } else {
    currBoroughs.splice(currBoroughs.indexOf(b), 1);
  } 
  
  tree.nodes(root).reverse().forEach(function(d) {
    if(d.depth == (maxDepth - 1) && d.children || d.hidden_children) {
      toggle(d);
      toggle(d);
    }
  });
  
  if (arraysEqual(currBoroughs, boroughs)) {  
    $("#all").addClass('active');
  } else {
    $("#all").removeClass('active');
  }

  update(root);
}

function toggleBK() {
  toggleBorough('BK');
}

function toggleMN() {
  toggleBorough('MN');
}

function toggleBX() {
  toggleBorough('BX');
}

function toggleSI() {
  toggleBorough('SI');
}

function toggleQN() {
  toggleBorough('QN');
}
/*
function drawPie(fac) {
  var data = fac.children ? fac.children : fac._children;
  
  var dataLength = data.length;
  
  dataLength = dataLength < 3 ? 3 : dataLength;
  dataLength = dataLength > 9 ? 9 : dataLength;

  var piesvgw = 280,
    piesvgh = 200,
    piew = 180,
    pieh = 180,
    radius = Math.min(piew, pieh) / 2;

  var color = d3.scale.ordinal()
      .range(colorbrewer.GnBu[dataLength]);

  var arc = d3.svg.arc()
      .outerRadius(radius - 10)
      .innerRadius(0);

  var pie = d3.layout.pie()
      .sort(null)
      .value(function(d) { return d.descend; });

  var piesvg = d3.select("#pieContainer").append("svg")
      .attr("width", piesvgw)
      .attr("height", piesvgh)
      .attr("visibility", "normal")
    .append("g")
      .attr("transform", "translate(" + piesvgw / 2 + "," + piesvgh / 2 + ")");

  
  data.forEach(function(d) {
    d.descend = numDescend(d);
    //d.descend = +d.population;
  });

    var g = piesvg.selectAll(".arc")
        .data(pie(data))
      .enter().append("g")
        .attr("class", "arc");

    g.append("path")
        .attr("d", arc)
        .style("opacity", ".7")
        .style("fill", function(d) { return color(d.data.name); });

    g.append("text")
        .attr("transform", function(d) {
          return "translate(" + 
            ( (radius - 12) * Math.sin( ((d.endAngle - d.startAngle) / 2) + d.startAngle ) ) +
            ", " +
            ( -1 * (radius - 12) * Math.cos( ((d.endAngle - d.startAngle) / 2) + d.startAngle ) ) +
          ")";
         })
        .attr("dy", ".35em")
        .style("text-anchor", "middle")
        .style("font-size", "8px")
        .text(function(d) { return d.data.name; }); 
}

  

$(".long").mouseover(function() {
    console.log("scrolling");
    //$(this).removeClass("ellipsis");
    var maxscroll = $(this).width();
    var speed = maxscroll * 15;
    $(this).animate({
        scrollLeft: maxscroll
    }, speed, "linear");
});

$(".long").mouseout(function() {
    $(this).stop();
    //$(this).addClass("ellipsis");
    $(this).animate({
        scrollLeft: 0
    }, 'slow');
});
*/

/*
    // Call visit function to establish maxLabelLength
    visit(root, function(d) {
        //totalNodes++;
        maxLabelLength = Math.max(d.name.length, maxLabelLength);

    }, function(d) {
        return d.children && d.children.length > 0 ? d.children : null;
    });
*/    

    </script>
  </body>
</html>
