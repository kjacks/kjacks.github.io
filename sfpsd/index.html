<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <style type="text/css">


.node circle {
  cursor: pointer;
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #f4f4f4;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      <div id="footer">
        New York City Facilities
        <form id="search"> Search for a Facility or Category 
          <input type="text" id="inputFac">
          <input type="button" value="Search" onClick='javascript:startSearch()'>
        </form>
      </div>
    </div>
    <script type="text/javascript">

var m = [20, 120, 20, 120],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root, fixedcopyjson;

var maxDepth = 4;
//var totalNodes = 0;
var maxLabelLength = 0;

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

d3.json("SFPSDparsed.json", function(json) {
  console.log(json);
  root = json;
  fixedcopyjson = json;
  root.x0 = h / 2;
  root.y0 = 0;

  function toggleAll(d) {
    if (d.children) {
      d.children.forEach(toggleAll);
      toggle(d);
    }
  }

  // A recursive helper function for performing some setup by walking through all nodes
  
    function visit(parent, visitFn, childrenFn) {
        if (!parent) return;

        visitFn(parent);

        var children = childrenFn(parent);
        if (children) {
            var count = children.length;
            for (var i = 0; i < count; i++) {
                visit(children[i], visitFn, childrenFn);
            }
        }
    }

    // Call visit function to establish maxLabelLength
    visit(root, function(d) {
        //totalNodes++;
        maxLabelLength = Math.max(d.name.length, maxLabelLength);

    }, function(d) {
        return d.children && d.children.length > 0 ? d.children : null;
    });


  root.children.forEach(toggleAll);
  //toggle(root.children[1]);
  //toggle(root.children[1].children[2]);
  //toggle(root);
 /* 
  toggle(root.children[1]);
  toggle(root.children[1].children[2]);
  toggle(root.children[9]);
  toggle(root.children[9].children[0]);
*/
  update(root);
});

/*
$(".long").mouseover(function() {
    console.log("scrolling");
    //$(this).removeClass("ellipsis");
    var maxscroll = $(this).width();
    var speed = maxscroll * 15;
    $(this).animate({
        scrollLeft: maxscroll
    }, speed, "linear");
});

$(".long").mouseout(function() {
    $(this).stop();
    //$(this).addClass("ellipsis");
    $(this).animate({
        scrollLeft: 0
    }, 'slow');
});
*/


function update(source) {
  console.log("in update");
  //calculates level with max number of nodes open, stores currently open nodes for each level in levelWidth array
  var levelWidth = [1];
  var childCount = function(level, n) {
    if (n.children && n.children.length > 0) {
      if (levelWidth.length <= level + 1) levelWidth.push(0);

      levelWidth[level + 1] += n.children.length;
      n.children.forEach(function(d) {
          childCount(level + 1, d);
      });
    }
  };
  childCount(0, root);
  console.log(levelWidth);
  //resizes tree based on level with most nodes open, only resizes if there is a level with greater than 50, otherwise sets to default height
  if(d3.max(levelWidth) >= 50) {
    var newHeight = d3.max(levelWidth) * 15; // 15 pixels per line  
    console.log(newHeight);
    tree.size([newHeight, w]);
    d3.select("svg").attr("height", newHeight + m[0]);
  } else {
    tree.size([h, w]);
    d3.select("svg").attr("height", h + m[0] + m[2]);
  }

  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { 
    console.log(d); 
    d.y = d.depth * 180;
    if (findOverlap(d) && d.name.length > 27 && d.depth != maxDepth) {
      var newDx = d.x + 15;
      while(findOverlap(newDx)) {
        console.log("finding newDx");
        newDx = newDx + 15;
      }
      d.x = newDx;
    }
    d.descend = numDescend(d);
  });

  
  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) {
        if (d.children == null) {
          d3.select(this).select("text").attr("font-weight", "bold");
        } else {
          d3.select(this).select("text").attr("font-weight", "normal");
        }
        toggle(d); 
        update(d); 
      })
      .on("mouseover", function(d) { 
        d3.select(this).attr("fill", "orange");
      })
      .on("mouseout", function(d) {  
        d3.select(this).attr("fill", "black");
      });;

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .attr("font-weight", function(d) { 
        if (d.children == null) {return "normal";} else {return "bold";}})
      //.attr("class", function(d) {if (d.name.length > 20) {return 'long';} else {return 'short'; } })
      .text(function(d) {return d.name;})
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  var radiusScale = d3.scale.log()
                    .domain([1, root.descend])
                    .range([2, 9]);

  nodeUpdate.select("circle")
      .attr("r", function(d) {console.log(d.name + " " + numDescend(d)); return radiusScale(d.descend);})
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
      /*.attr("stroke", function(d) {
        if ((d.source.children != null) && (d.target.children != null)) {
          return "black";
        } else {
          return "#edecea";
        }})*/
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
  /*
  visit(node, function(d) {
        //maxLabelLength = Math.max(d.name.length, maxLabelLength);
        //console.log(d.name);
        console.log(d.);
    }, function(d) {
        return d.children && d.children.length > 0 ? d.children : null;
    });
*/

}

// Toggle children.
function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
    //d.select("text").attr("font-weight", "bold");
  }
}

function visit(parent, visitFn, childrenFn) {
        if (!parent) return;

        visitFn(parent);

        var children = childrenFn(parent);
        if (children) {
            var count = children.length;
            for (var i = 0; i < count; i++) {
                visit(children[i], visitFn, childrenFn);
            }
        }

}
    
function findOverlap(node) {
    if (node.hasOwnProperty('parent')) {
      if (node.parent.hasOwnProperty('parent')) {
        var parofpar = node.parent.parent;
        for (var i = 0; i < parofpar.children.length; i++) {
          if((parofpar.children[i].x >= (node.x - 15)) && (parofpar.children[i].x <= (node.x + 15))) {
            console.log("overlap!");
            return true;
          }
        }
      }
    }

  }

function numChildren(node) {
  if (node.hasOwnProperty('children')) {
    if (node.children == null) {
      return node._children.length;
    } else {
      return node.children.length;
    }
  } else {
    return 0;
  }
}

function numDescend(node) {
  if(node.descend) {
    console.log("already computed");
    return node.descend;
  }
  var totDescend = 0;
  visit(node, function(d) {
        d.children || d._children ? null : totDescend++;
    }, function(d) {
        var ret_value = d.children && d.children.length > 0 || d._children && d._children.length > 0 ? d.children || d._children : null;
        return ret_value;
    });
  return totDescend;
}


/*
function numDescend(node) {
  //console.log(node);
  var currLen = numChildren(node);
  //if (currLen == 0) {
  //  return 0;
  //}
  var count = 0;
  for (var i = 0; i < currLen; i++) {
    if (node.children == null) {
      count += numDescend(node._children[i]);
    } else {
      count += numDescend(node.children[i]);
    }
  }
  return count;
}
*/

var foundCoord = [];
var found = false;

function findFacility(facility, node) {
  if (node == null || found == true) {
    return;
  }
  if (node.hasOwnProperty("children") == false) {
    return;
  }

  var count = 0;
  var ch = [];
  if (node.children == null) {
    count = node._children.length;
    ch = node._children;
  } else {
    count = node.children.length;
    ch = node.children;
  }
    console.log(count);
    for (var i = 0; i < count; i++) {
      if (ch[i].name == facility) {
        console.log("found!");
        foundCoord.push(i);
        found = true;
        return;
      } else {
        findFacility(facility, ch[i]);
        if (found == true) {
          foundCoord.push(i);
          return;
        }
      }
    }
  
}

function openTree(foundCoord) {
  var curr = root;
  while (foundCoord.length > 0) {
    var index = foundCoord.pop();
    if (curr.children == null) {
      curr = curr._children[index];
    } else {
      curr = curr.children[index];
    }
    
    toggle(curr);
  }
  update(root);
}

function startSearch() {
  foundCoord = [];
  found = false;
  console.log("starting search");
  var toFind = document.getElementById('inputFac').value;
  console.log(toFind);
  findFacility(toFind, root);
  console.log("foundCoord: " + foundCoord);
  if (foundCoord.length < 1) {
    console.log("not found");
  } else {
    console.log("opening tree");
    openTree(foundCoord);
  }
}
    

    </script>
  </body>
</html>
