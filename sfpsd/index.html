<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <style type="text/css">


.node circle {
  cursor: pointer;
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node text {
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #f4f4f4;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      <div id="title">
        New York City Facilities
        <form id="search"> Search for a Facility or Category 
          <input type="text" id="inputFac">
          <input type="button" value="Search" onClick='javascript:startSearch()'>
        </form>
      </div>
    </div>
    <script type="text/javascript">
d3.selection.prototype.moveToBack = function() { 
    return this.each(function() { 
        var firstChild = this.parentNode.firstChild; 
        if (firstChild) { 
            this.parentNode.insertBefore(this, firstChild); 
        } 
    }); 
};
//set dimensions and margins
var m = [40, 120, 20, 85],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root;

//maximum depth of the tree, used to determine if node is leaf, FUTURE:should use a function to set
var maxDepth = 4
  labelCutoff = 35
  selectColor = "#f7b425"
  hoverColor = "#89aad3";

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

d3.json("SFPSDparsedattr.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;

  function toggleAll(d) {
    if (d.children) {
      d.children.forEach(toggleAll);
      toggle(d);
    }
  }

  root.children.forEach(toggleAll);

  update(root);
});

function update(source) {
  resizeSvg();

  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  // set node x,y postions and count descendents
  nodes.forEach(function(d) { 
    d.y = d.depth * 225;
    /*
    //if overlap found and name is long and is not a leaf, offset
    if (findOverlap(d) && d.name.length > 27 && d.depth != maxDepth) {
      var newDx = d.x + 15;
      /*while(findOverlap(newDx)) {
        newDx = newDx + 15;
      }
      d.x = newDx;

    }*/
    d.descend = numDescend(d);
  });

  var radiusScale = d3.scale.log()
                    .domain([1, root.descend])
                    .range([1, 8]);

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) {
        if (d.children == null) {
          d3.select(this).select("text").attr("font-weight", "bold").attr("fill", selectColor);
        } else {
          d3.select(this).select("text").attr("font-weight", "normal").attr("fill", "black");
        }
        d.children || d._children ? toggle(d) : openMap(d); 
        update(d);
        
      })
      .on("mouseover", function(d) { 
        d3.select(this).select("text").attr("fill", function(d) {return d.children ?  selectColor : hoverColor;});
        d3.select(this).select("text").text(function(d) {return d.name;});
        if (d.name.length > labelCutoff) {
          var xpadding = 4
              ypadding = 2;
          var bbox = this.getBBox();
          var rect = d3.select(this).append("rect")
            .attr("x", bbox.x - xpadding)
            .attr("y", bbox.y - ypadding)
            .attr("width", (bbox.width - 15) + (xpadding * 2))
            .attr("height", bbox.height + (ypadding * 2))
            //.insertBefore()
            .style("fill", "white")
            .moveToBack();
        }
      })
      .on("mouseout", function(d) {
        d3.select("rect").remove();  
        d3.select(this).select("text").attr("fill", function(d) {return d.children ? selectColor : "black";});
        d3.select(this).select("text").text(function(d) 
          {return d.name.length > labelCutoff ? d.name.substr(0,labelCutoff) + "..." : d.name;})
      });

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("svg:text")
      .attr("x", function(d) { 
        var offset = radiusScale(d.descend) + 5;
        return offset * (d.children || d._children ? -1 : 1); })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .attr("font-weight", function(d) { return d.children ? "bold" : "normal";})
      .attr("fill", function(d) { return d.children ? selectColor : "black";})
      .text(function(d) {
        return d.name.length > labelCutoff ? d.name.substr(0,labelCutoff) + "..." : d.name;})
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  

  nodeUpdate.select("circle")
      .attr("r", function(d) {return radiusScale(d.descend);})
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });

}

// Toggle children.
function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
}

//calculates level with max number of nodes open, stores currently open nodes for each level in levelWidth array
function resizeSvg() {
  var levelWidth = [1];
  var childCount = function(level, n) {
    if (n.children && n.children.length > 0) {
      if (levelWidth.length <= level + 1) levelWidth.push(0);

      levelWidth[level + 1] += n.children.length;
      n.children.forEach(function(d) {
          childCount(level + 1, d);
      });
    }
  };
  childCount(0, root);
  //resizes tree based on level with most nodes open, only resizes if there is a level with greater than 50, otherwise sets to default height
  if(d3.max(levelWidth) >= 50) {
    var newHeight = d3.max(levelWidth) * 15; // 15 pixels per line  
    tree.size([newHeight, w]);
    d3.select("svg").attr("height", newHeight + m[0]);
  } else {
    tree.size([h, w]);
    d3.select("svg").attr("height", h + m[0] + m[2]);
  }
}

// A recursive helper function for performing some setup by walking through all nodes
function visit(parent, visitFn, childrenFn) {
  if (!parent) return;

  visitFn(parent);

  var children = childrenFn(parent);
  if (children) {
    var count = children.length;
    for (var i = 0; i < count; i++) {
      visit(children[i], visitFn, childrenFn);
    }
  }
}
    
function findOverlap(node) {
  if (node.hasOwnProperty('parent')) {
    if (node.parent.hasOwnProperty('parent')) {
      var parofpar = node.parent.parent;
      for (var i = 0; i < parofpar.children.length; i++) {
        if((parofpar.children[i].x >= (node.x - 15)) && (parofpar.children[i].x <= (node.x + 15))) {
          return true;
        }
      }
    }
  }
}

function numChildren(node) {
  if (node.hasOwnProperty('children')) {
    if (node.children == null) {
      return node._children.length;
    } else {
      return node.children.length;
    }
  } else {
    return 0;
  }
}

function numDescend(node) {
  if(node.descend) {
    return node.descend;
  }
  var totDescend = 0;
  visit(node, function(d) {
        d.children || d._children ? null : totDescend++;
    }, function(d) {
        var ret_value = d.children && d.children.length > 0 || d._children && d._children.length > 0 ? d.children || d._children : null;
        return ret_value;
    });
  return totDescend;
}
//
//functions to execute search
//
var foundCoord = [];
var found = false;

function findFacility(facility, node) {
  if (node == null || found == true) {
    return;
  }
  if (node.hasOwnProperty("children") == false) {
    return;
  }

  var count = 0;
  var ch = [];
  if (node.children == null) {
    count = node._children.length;
    ch = node._children;
  } else {
    count = node.children.length;
    ch = node.children;
  }
    for (var i = 0; i < count; i++) {
      if (ch[i].name.toLowerCase() == facility) {
        console.log("found!");
        foundCoord.push(i);
        found = true;
        return;
      } else {
        findFacility(facility, ch[i]);
        if (found == true) {
          foundCoord.push(i);
          return;
        }
      }
    }
  
}

function openTree(foundCoord) {
  var curr = root;
  while (foundCoord.length > 0) {
    var index = foundCoord.pop();
    if (curr.children == null) {
      curr = curr._children[index];
    } else {
      curr = curr.children[index];
    }
    
    toggle(curr);
  }
  update(root);
}

function startSearch() {
  foundCoord = [];
  found = false;
  console.log("starting search");
  var toFind = (document.getElementById('inputFac').value).toLowerCase();
  console.log(toFind);
  findFacility(toFind, root);
  console.log("foundCoord: " + foundCoord);
  if (foundCoord.length < 1) {
    alert(toFind + " not found");
  } else {
    console.log("opening tree");
    openTree(foundCoord);
  }
}

function openMap(fac) {
  console.log("opening map");
  window.open("http://maps.google.com?q=" + fac.name);
}
/*
$(".long").mouseover(function() {
    console.log("scrolling");
    //$(this).removeClass("ellipsis");
    var maxscroll = $(this).width();
    var speed = maxscroll * 15;
    $(this).animate({
        scrollLeft: maxscroll
    }, speed, "linear");
});

$(".long").mouseout(function() {
    $(this).stop();
    //$(this).addClass("ellipsis");
    $(this).animate({
        scrollLeft: 0
    }, 'slow');
});
*/

/*
    // Call visit function to establish maxLabelLength
    visit(root, function(d) {
        //totalNodes++;
        maxLabelLength = Math.max(d.name.length, maxLabelLength);

    }, function(d) {
        return d.children && d.children.length > 0 ? d.children : null;
    });
*/    

    </script>
  </body>
</html>
